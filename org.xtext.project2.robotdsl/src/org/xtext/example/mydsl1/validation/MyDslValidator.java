/*
 * generated by Xtext 2.34.0
 */
package org.xtext.example.mydsl1.validation;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.xtext.example.typing.ExpressionsType;
import org.xtext.example.typing.ExpressionsTypeProvider;

import project2.Action;
import project2.Button;
import project2.Condition;
import project2.Event;
import project2.Expression;
import project2.LightAction;
import project2.MotorAction;
import project2.MusicSetting;
import project2.Project2Package;
import project2.Sensor;
import project2.Sound;
import project2.SoundAction;
import project2.Tap;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class MyDslValidator extends AbstractMyDslValidator {
	
	public static final String SAME_ACTION_TYPE = "Can't add two same actions";

	@Check
	public void checkActions(Event event) {
		boolean[] flags= new boolean[3];
		for(Action a : event.getActions()) {
			int pos = 0;
			if(a instanceof LightAction) {
				pos = 2;
			}else if(a instanceof SoundAction) {
				pos = 1;
			}
			if(flags[pos]) {
				error("cant add two same action type",
						event,
						Project2Package.eINSTANCE.getEvent_Actions(),
						SAME_ACTION_TYPE);
			}else {
				flags[pos] = true;
			}
		}
	}
	
	public static final String INVALID_SPEED = "the speed exceed the limit";
	
	@Check
	public void checkMotorSpeed(MotorAction ma) {
		int max = 500,
			min = -500;
		
		if(ma.getMotorLeft() < min || ma.getMotorLeft() > max) {
			error("the motor speed can only between " + min +" to " + max,
					ma,
					Project2Package.eINSTANCE.getMotorAction_MotorLeft(),
					INVALID_SPEED);
		}
		if(ma.getMotorRight() < min || ma.getMotorRight() > max) {
			error("the motor speed can only between " + min +" to " + max,
					ma,
					Project2Package.eINSTANCE.getMotorAction_MotorRight(),
					INVALID_SPEED);
		}
		
	}
	
	public static final String INVALID_SENSOR_POS = "the sensor position is invalid";
	
	@Check
	public void checkSensor(Sensor s) {
		int max = 9,
			min = 1;
		
		if(s.getSensorPos() < min || s.getSensorPos() > max) {
			error("the sensor position can only between " + min +" to " + max,
					s,
					Project2Package.eINSTANCE.getSensor_SensorPos(),
					INVALID_SENSOR_POS);
		}
	}
	
	public static final String INVALID_CONDITION = "the contidion cant ";
	
	@Check
	public void checkCondition(Event e) {
		if(e.getConditions().size()>1) {
			if( (e.getConditions().get(0) instanceof Tap || e.getConditions().get(0) instanceof Sound)) {
				error("this condition can only be singular",
						e,
						Project2Package.eINSTANCE.getEvent_Conditions(),
						INVALID_CONDITION);
			}else {
				Condition c = e.getConditions().get(0);
				for(int i = 1; i < e.getConditions().size(); i++) {
					if(c instanceof Button && !(e.getConditions().get(i) instanceof Button)) {
						error("this condition can only assing with same type of condition",
								e,
								Project2Package.eINSTANCE.getEvent_Conditions(),
								INVALID_CONDITION);
					}else if(c instanceof Sensor &&!(e.getConditions().get(i) instanceof Sensor)) {
						error("this condition can only assing with same type of condition",
								e,
								Project2Package.eINSTANCE.getEvent_Conditions(),
								INVALID_CONDITION);
					}
				}
			}	
		}
		
		
		
		
	}
	
	public static final String INVALID_COLOR = "the color setting cant > 32";
	
	@Check
	public void checkLightColor(LightAction la) {
		int max = 32,
			min = 0;
		
		if(la.getRed() < min || la.getRed() > max) {
			error("the red value can only being between " + min +" to " + max,
					la,
					Project2Package.eINSTANCE.getLightAction_Red(),
					INVALID_COLOR);
		}
		if(la.getBlue() < min || la.getBlue() > max) {
			error("the blue value can only being between " + min +" to " + max,
					la,
					Project2Package.eINSTANCE.getLightAction_Blue(),
					INVALID_COLOR);
		}
		
		if(la.getGreen() < min || la.getGreen() > max) {
			error("the green value can only being between " + min +" to " + max,
					la,
					Project2Package.eINSTANCE.getLightAction_Green(),
					INVALID_COLOR);
		}
		
	}
	
	public static final String INVALID_SOUND_NOTE = "the sound note cant assign this value";
	public static final String INVALID_SOUND_POS = "the sound position cant assign this value";
	public static final String SAME_SOUND_POS = "this sound position is already defined";
	
	@Check
	public void checkSound(SoundAction sa) {
		int max_note = 5,
			max_pos = 6,
			min = 1;
		List<Integer> li = new ArrayList<>();
		for(MusicSetting m : sa.getMusicsettings()) {
			if(m.getNote() < min || m.getNote() > max_note) {
				error("the sound note can only being between " + min +" to " + max_note,
					m,
					Project2Package.eINSTANCE.getMusicSetting_Note(),
					INVALID_SOUND_NOTE);
			}
			if(m.getPos() < min || m.getPos() > max_pos) {
				error("the sound position can only being between " + min +" to " + max_pos,
					m,
					Project2Package.eINSTANCE.getMusicSetting_Pos(),
					INVALID_SOUND_POS);
			}
			if(li.contains(m.getPos())) {
				error("this sound position is already defined",
						m,
						Project2Package.eINSTANCE.getMusicSetting_Pos(),
						SAME_SOUND_POS);
			}else {
				li.add(m.getPos());
			}
		}
		
		
	}
	
	
	public static final String INVALID_TYPE = "the type is invalid";
	
	@Check
	public void CheckType(Expression e) {
		String[] tempArray = {"||", "&&", "==", "!="};
		List<String> boolOpBinary = new ArrayList<>(Arrays.asList(tempArray));
		String[] tempArrayInt = {"+", "-", "/", "*", ">", ">=", "<","<="};
		List<String> intOpBinary = new ArrayList<>(Arrays.asList(tempArrayInt));
		if(boolOpBinary.contains(e.getOperation())) {
			ExpressionsType typeLeft  = checkAgainstNull(e.getLeft(), Project2Package.eINSTANCE.getExpression_Left());
			ExpressionsType typeRight  = checkAgainstNull(e.getRight(), Project2Package.eINSTANCE.getExpression_Right());
			if(e.getOperation().equals("==") || e.getOperation().equals("!=")) {
				if (typeLeft != typeRight){
					error("should has same type", Project2Package.eINSTANCE.getExpression_Left(), INVALID_TYPE);
					error("should has same type", Project2Package.eINSTANCE.getExpression_Right(), INVALID_TYPE);
				}
			}else {
				checkAgainst(typeLeft, ExpressionsTypeProvider.boolType,Project2Package.eINSTANCE.getExpression_Left());
				checkAgainst(typeRight, ExpressionsTypeProvider.boolType,Project2Package.eINSTANCE.getExpression_Right());
			}
			
		}else if(intOpBinary.contains(e.getOperation())) {
			ExpressionsType typeLeft  = checkAgainstNull(e.getLeft(), Project2Package.eINSTANCE.getExpression_Left());
			ExpressionsType typeRight  = checkAgainstNull(e.getRight(), Project2Package.eINSTANCE.getExpression_Right());
			checkAgainst(typeLeft, ExpressionsTypeProvider.intType,Project2Package.eINSTANCE.getExpression_Left());
			checkAgainst(typeRight, ExpressionsTypeProvider.intType,Project2Package.eINSTANCE.getExpression_Right());
		}else if(e.getOperation().equals("!")) {
			ExpressionsType typeLeft  = checkAgainstNull(e.getLeft(), Project2Package.eINSTANCE.getExpression_Left());
			checkAgainst(typeLeft, ExpressionsTypeProvider.boolType,Project2Package.eINSTANCE.getExpression_Left());
		}else if(e.getOperation().equals("if")) {
			ExpressionsType typeLeft  = checkAgainstNull(e.getLeft(), Project2Package.eINSTANCE.getExpression_Left());
			checkAgainst(typeLeft, ExpressionsTypeProvider.boolType,Project2Package.eINSTANCE.getExpression_Left());
		}else if(e.getOperation().equals("then")) {
			ExpressionsType typeLeft  = checkAgainstNull(e.getLeft(), Project2Package.eINSTANCE.getExpression_Left());
			ExpressionsType typeRight  = ExpressionsTypeProvider.typeOf(e.getRight());
			if(typeRight != null) {
				if (typeLeft != typeRight){
					error("the then should has same return type as else", Project2Package.eINSTANCE.getExpression_Left(), INVALID_TYPE);
					error("the else should has same return type as then", Project2Package.eINSTANCE.getExpression_Right(), INVALID_TYPE);
				}
			}
		}
	}
	
	private ExpressionsType checkAgainstNull (Expression input, EReference ref) {
		// get type of expression
		ExpressionsType type = ExpressionsTypeProvider.typeOf(input);
		// create error if expression has null type (error)
		if (type == null)
			error ("the type is null", ref);
		return type;
	}
	
	private void checkAgainst (ExpressionsType actualType, ExpressionsType expectedType, EReference ref) {
		if (actualType != expectedType)
			error("expected type " + expectedType +
				  " but was " + actualType,
				  ref
				  );
	}
}
